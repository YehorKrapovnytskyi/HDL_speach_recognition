// -------------------------------------------------------------
// 
// File Name: ..\..\hw\CIC_decimator_HDL_model\scaling_to_16bit.v
// Created: 2022-05-20 22:52:52
// 
// Generated by MATLAB 9.5 and HDL Coder 3.13
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: scaling_to_16bit
// Source Path: CIC_decimator_HDL_model/CIC_decimator_HDL_model/scaling_to_16bit
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module scaling_to_16bit
          (i_clk,
           i_rst_n,
           enb,
           i_data,
           i_en,
           o_data);


  input   i_clk;
  input   i_rst_n;
  input   enb;
  input   signed [30:0] i_data;  // sfix31
  input   i_en;
  output  signed [15:0] o_data;  // int16


  reg  [0:1] reduced_reg;  // ufix1 [2]
  wire [0:1] reduced_reg_next;  // ufix1 [2]
  wire i_en_1;
  reg  [0:1] reduced_reg_1;  // ufix1 [2]
  wire [0:1] reduced_reg_next_1;  // ufix1 [2]
  wire i_en_2;
  reg signed [30:0] Unit_Delay_Enabled_Synchronous_out1;  // sfix31
  wire signed [30:0] Unit_Delay_Enabled_Synchronous_ectrl;  // sfix31
  wire signed [30:0] Shift_Arithmetic_out1;  // sfix31
  reg signed [30:0] Shift_Arithmetic_out1_1;  // sfix31
  wire [7:0] Constant_out1;  // uint8
  reg [7:0] Constant_out1_1;  // uint8
  wire signed [39:0] Multiply_mul_temp;  // sfix40
  wire signed [8:0] Multiply_1;  // sfix9
  wire signed [38:0] Multiply_out1;  // sfix39
  reg signed [38:0] Multiply_out1_1;  // sfix39
  wire signed [30:0] Multiply_out1_2;  // sfix31
  wire [15:0] Bit_Slice_out1;  // uint16
  wire signed [15:0] Data_Type_Conversion1_out1;  // int16
  reg signed [15:0] Unit_Delay_Enabled_Synchronous1_out1;  // int16
  wire signed [15:0] Unit_Delay_Enabled_Synchronous1_ectrl;  // int16


  always @(posedge i_clk or negedge i_rst_n)
    begin : reduced_process
      if (i_rst_n == 1'b0) begin
        reduced_reg[0] <= 1'b0;
        reduced_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          reduced_reg[0] <= reduced_reg_next[0];
          reduced_reg[1] <= reduced_reg_next[1];
        end
      end
    end

  assign i_en_1 = reduced_reg[1];
  assign reduced_reg_next[0] = i_en;
  assign reduced_reg_next[1] = reduced_reg[0];



  always @(posedge i_clk or negedge i_rst_n)
    begin : reduced_1_process
      if (i_rst_n == 1'b0) begin
        reduced_reg_1[0] <= 1'b0;
        reduced_reg_1[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          reduced_reg_1[0] <= reduced_reg_next_1[0];
          reduced_reg_1[1] <= reduced_reg_next_1[1];
        end
      end
    end

  assign i_en_2 = reduced_reg_1[1];
  assign reduced_reg_next_1[0] = i_en_1;
  assign reduced_reg_next_1[1] = reduced_reg_1[0];



  assign Unit_Delay_Enabled_Synchronous_ectrl = (i_en_1 == 1'b0 ? Unit_Delay_Enabled_Synchronous_out1 :
              i_data);



  always @(posedge i_clk or negedge i_rst_n)
    begin : Unit_Delay_Enabled_Synchronous_lowered_process
      if (i_rst_n == 1'b0) begin
        Unit_Delay_Enabled_Synchronous_out1 <= 31'sb0000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Unit_Delay_Enabled_Synchronous_out1 <= Unit_Delay_Enabled_Synchronous_ectrl;
        end
      end
    end



  assign Shift_Arithmetic_out1 = Unit_Delay_Enabled_Synchronous_out1 >>> 8'd2;



  always @(posedge i_clk or negedge i_rst_n)
    begin : HwModeRegister_process
      if (i_rst_n == 1'b0) begin
        Shift_Arithmetic_out1_1 <= 31'sb0000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Shift_Arithmetic_out1_1 <= Shift_Arithmetic_out1;
        end
      end
    end



  assign Constant_out1 = 8'b00001011;



  always @(posedge i_clk or negedge i_rst_n)
    begin : HwModeRegister1_process
      if (i_rst_n == 1'b0) begin
        Constant_out1_1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Constant_out1_1 <= Constant_out1;
        end
      end
    end



  assign Multiply_1 = {1'b0, Constant_out1_1};
  assign Multiply_mul_temp = Shift_Arithmetic_out1_1 * Multiply_1;
  assign Multiply_out1 = Multiply_mul_temp[38:0];



  always @(posedge i_clk or negedge i_rst_n)
    begin : PipelineRegister_process
      if (i_rst_n == 1'b0) begin
        Multiply_out1_1 <= 39'sh0000000000;
      end
      else begin
        if (enb) begin
          Multiply_out1_1 <= Multiply_out1;
        end
      end
    end



  assign Multiply_out1_2 = ((Multiply_out1_1[38] == 1'b0) && (Multiply_out1_1[37:30] != 8'b00000000) ? 31'sb0111111111111111111111111111111 :
              ((Multiply_out1_1[38] == 1'b1) && (Multiply_out1_1[37:30] != 8'b11111111) ? 31'sb1000000000000000000000000000000 :
              $signed(Multiply_out1_1[30:0])));



  assign Bit_Slice_out1 = Multiply_out1_2[30:15];



  assign Data_Type_Conversion1_out1 = Bit_Slice_out1;



  assign Unit_Delay_Enabled_Synchronous1_ectrl = (i_en_2 == 1'b0 ? Unit_Delay_Enabled_Synchronous1_out1 :
              Data_Type_Conversion1_out1);



  always @(posedge i_clk or negedge i_rst_n)
    begin : Unit_Delay_Enabled_Synchronous1_lowered_process
      if (i_rst_n == 1'b0) begin
        Unit_Delay_Enabled_Synchronous1_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Unit_Delay_Enabled_Synchronous1_out1 <= Unit_Delay_Enabled_Synchronous1_ectrl;
        end
      end
    end



  assign o_data = Unit_Delay_Enabled_Synchronous1_out1;

endmodule  // scaling_to_16bit

